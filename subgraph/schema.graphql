type Project @entity {
  id: ID!
  # From IPFS / off chain storage
  name: String!
  description: String!
  website: String
  twitter: String
  github: String # Make sure we call it github or something else
  avatar: String
  image: String
  ipfsHash: String!
  categories: [Category!]!

  # From smart contracts directly
  owner: User
  isChallenged: Boolean
  challenges: [Challenge!]
  isWhitelistedProject: Boolean! # check with Brandon
  createdAt: Int! # This would allow you to know when it will become a full member too
  delegateAddress: Bytes # Null if no delegate is set
  isRepresentative: Boolean

  # Derived from smart contract events
  totalVotes: Int!
  reputation: Int!

  # All votes a Project has made
  votes: [Vote!] @derivedFrom(field: "voter")
}

type Category @entity {
  id: ID!
  name: String!
  description: String!
  slug: String!
  projects: [Project!]
  subcategories: [Category!] @derivedFrom(field: "parentCategory")
  parentCategory: Category
}

type Challenge @entity {
  id: ID!
  description: String
  createdAt: Int!
  votesFor: Int!
  votesAgainst: Int!
  project: Project!
  owner: Bytes!
  resolved: Boolean! #  means it's a past challenge
  votes: [Vote!] @derivedFrom(field: "challenge")
}

# For global variables
type Everest @entity {
  id: ID!
  period: Int! # how long the challenge will last
  votingPeriodDuration: Int!
  whitelistPeriodDuration: Int!
  challengeDeposit: BigInt!
  applicationFee: BigInt!
  approvedToken: Bytes!
  reserveBank: Bytes!
  registry: Bytes!
}

type Vote @entity {
  id: ID! # concatenation of challenge ID and voter address
  voter: Project!
  challenge: Challenge!
  choice: Choice!
}

enum Choice {
  RemoveProject
  KeepProject
}

type User @entity {
  id: ID!
  name: String
  bio: String
  projects: [Project!]
  challenges: [Challenge!] # challenges you started
  votes: [Project!] # participation in other people's challenges
}
